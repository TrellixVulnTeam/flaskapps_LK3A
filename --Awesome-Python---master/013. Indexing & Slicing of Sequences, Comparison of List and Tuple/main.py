# Sequence 객체들은 요소의 임의 접근을 위해 indexing과 slicing이라는 개념을 지원

l = [1, 2, 3, 4, 5]
t = 1, 2, 3, 4, 5

# -- Indexing
print(l[0]) # 1
print(t[1]) # 2
# l[n] = n번째 인덱스의 요소를 반환
# 가장 첫 요소는 0번 인덱스를 가짐
l[4] = 9
# 특정 인덱스의 요소를 변경

# t[4] = 9
# 튜플은 불가능. 리스트와 튜플은 모두 '순서 있는 값의 집합'을 다루지만,
# read/write 모두 가능한지(list) / read만 가능한지(tuple)에 대해 차이점이 존재
# tuple은 제한만 많고 불필요한 것처럼 보이지만, 동일한 양의 데이터를 저장하고 있더라도 list는 확장을 대비하여 tuple보다 많은 메모리를 사용함

# -- Slicing
print(l[0:3]) # [1, 2, 3]
print(t[1:3]) # (2, 3)
# seq[n:m] = n부터 m-1까지의 요소를 오른쪽 방향으로 참조하며 원본 sequence의 타입으로 반환

print(l[:3]) # [1, 2, 3]
print(t[1:]) # (2, 3, 4, 5)
# seq[n:m]에서, n의 0은 생략 가능하며, '맨 끝까지 슬라이싱'은 m을 생략하여 표현 가능

print(l[1:None]) # [2, 3, 4, 5]
# 생략을 위해 None을 사용할 수도 있음

print(t[3:0])# ()
# seq[n:m]에서, n이 m보다 큰 경우에는 빈 sequence가 반환됨

print(t[:]) # (1, 2, 3, 4, 5)
# 해당 sequence 전체에 대한 얕은 복사(shallow copy)
# Python에서 객체를 복사할 때 자주 사용되는 고급 패턴 중 하나
