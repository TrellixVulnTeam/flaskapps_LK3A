"""
    GIL 全局解释器锁 --- 多线程在**python解释器**的作用下，抢锁的行为

    1- windows的QQ.exe不能安装到linux系统上，C语言把代码通过编译器变成二进制给linux识别
    2- Python解释器，也成为虚拟机，就是自己安装的python 3.7 interpreter解释器的意思，python文件运行在这个虚拟的运行环境
    3- C语言通过不同的编译器运行在不同的系统下，是一种编译性语言，说完5分钟，才开始翻译，浪费了大量的编译时间，省去运行时间
    4- Python通过一个python解释器虚拟环境运行在不同操作系统下，是一种解释性语言，类似于同声传译，翻译一行，运行一行，编译时间短，运行时间长

    5- python多线程情况下是一种**假的多线程**，多个线程抢不同的运行时间，这种现象就叫做GIL，全局解释器锁
    6- 要想解决GIL全局解释器锁，要么**换python解释器**，要么**python调用c语言启动多线程**
"""

"""
    1- python语言和GIL没有半毛钱关系，仅仅是由于历史原因在Cpython虚拟机(解释器)，难以移除GIL
    2- GIL：每个线程在执行的时候都需要获取GIL锁，保证同一时刻只有一个线程可以执行代码
    3- 线程释放GIL锁的情况：在IO操作可能引起阻塞之前，暂时释放gil，但是执行完后必须重新获取GIL
    4- Python使用**多进程**是可以调用多核cpu资源的

    为什么python中有了GIL保证统一时刻只有一个线程执行代码为什么线程还需要互斥锁？
    1- GIL只能保证同一时刻只有一个线程在做，但是不能保证切换的过程中这个事情被该线程完成了
    2- 互斥锁能够保证在线程切换之前，事情做完，取值 -- 修改 -- 赋值
    3- 类似于厨房规定一个线程只能用10分钟做饭，如果每个线程都能在10分钟内做完走出厨房，那么GIL就没问题
    4- 但是如果有的线程没有在10分钟内完成，切换到另一个线程去厨房做饭，那么只能在前线程的基础上进行修改
    
    计算密集型 --> 多进程
    IO密集型 --> 多线程，协程
"""

"""
    1- libdead_loop.so是编译好的二进制C语言
    2- 主线程需要使用python解释器运行，但是执行编译好的二进制c语言文件不再需要python解释器
    3- 这样可以实现两个线程同时运行，占用两个核心，而不再是假的多线程
    
"""
from ctypes import *
from threading import Thread

# 加载动态库，用以执行二进制文件,文件中有一个DeadLoop方法
lib = cdll.LoadLibrary("./libdead_loop.so")

# 创建一个子线程，让其执行c语言编写的函数
thd = Thread(target=lib.DeadLoop)
thd.start()

# 主线程
while True:
    pass
